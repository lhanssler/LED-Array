import pyfirmata
import time
import numpy as np

def board_initializer(port=None):
    '''
    param str port: Location of Arduino board. Default None prompts user to input string
    
    Initializes connection with the Arduino board in port. Returns the board object.
    '''
    
    if port == None:
        port = input('What is the port?')
    
    pyboard = pyfirmata.Arduino(port)
    return pyboard

def LED_setup(pyboard, file):
    '''
    param Arduino pyboard: Connection with the Arduino board
    param ndarray file: Contents of the setup file fed from main as ndarray
    
    Initializes the LED setup as dict LED_array.
    LED_array has key=LED_num (int corresponding to a given LED) and value=[anode_pin, cathode_pin].
    Returns LED_array.
    '''
    
    # Reading the initializing txt file to save which rows/cols correspond to which pins & which are anodes
    rows = {}; cols = {}
    for pin in file:
        if pin[1] != 0:
            rows[pin[1]] = [pyboard.digital[int(pin[0])], pin[3]]
        else:
            cols[pin[2]] = [pyboard.digital[int(pin[0])], pin[3]]
    
    # Setting up LED_array
    LED_counter = 0
    LED_array = {}
    while LED_counter < len(rows) * len(cols):
        LED_counter += 1
        c = LED_counter % len(cols)
        if c == 0:
            c += len(cols)
        r = int(np.ceil(LED_counter / len(cols)))
        r_pin = rows[r]
        c_pin = cols[c]
        
        if r_pin[1] == c_pin[1]:
            # This means both row and col are labeled as anodes
            print("ERROR!!!")
        if c_pin[1] == 1:
            # This sets the LED to be [col, row] as [anode, cathode]
            LED_array[LED_counter] = [c_pin[0], r_pin[0]]
        else:
            # This sets LED to be [row, col] as [anode, cathode] (default setting)
            LED_array[LED_counter] = [r_pin[0], c_pin[0]]
        
    return LED_array

def global_off(LED_array):
    '''
    param dict LED_array: key=int corresponding to an LED, value=[anode_pin, cathode_pin]
    
    Sets all pins to mode 1 (write), sets all pins to low voltage (write(0)), then sets all pins to mode 0 (read).
    Loops over all LEDs in LED_array to do so.
    Read mode (0) with low voltage (0) pre-set for write mode (1) is used as default for all pins.
    '''
    
    for LED_num in LED_array:
        row = LED_array[LED_num][0]
        if row.mode != 1:
            row.mode = 1
        row.write(0)
        row.mode = 0
        
        col = LED_array[LED_num][1]
        if col.mode != 1:
            col.mode = 1
        col.write(0)
        col.mode = 0
        
def global_on(LED_array, read=True):
    '''
    param dict LED_array: key=int corresponding to an LED, value=[anode_pin, cathode_pin]
    param bool read: Default True sets all pins to read mode after being set to high voltage; False cancels this
    
    Sets all pins to mode 1 (write), sets all pins to high voltage (write(1)), then sets all pins to mode 0 (read).
    Loops over all LEDs in LED_array to do so.
    '''
    
    for LED_num in LED_array:
        row = LED_array[LED_num][0]
        if row.mode != 1:
            row.mode = 1
        row.write(1)
        
        col = LED_array[LED_num][1]
        if col.mode != 1:
            col.mode = 1
        col.write(1)
        
        if read:
            row.mode = 0
            col.mode = 0
    
def LED_flash(LED_array, LED_num, num_flashes, half_flash_length=0.5):
    '''
    param dict LED_array: key=int corresponding to an LED, value=[anode_pin, cathode_pin]
    param int LED_num: Number corresponding to the LED that should flash
    param int num_flashes: Number of times to flash LED l
    param float half_flash_length: Time LED is turned on/off for (half the period of a flash) in seconds
    
    In one on-off cycle:
        Turns on LED_num by setting anode/cathode to mode 1 (write) with low/high V, respectively.
        Waits half_flash_length seconds.
        Turns off LED_num by setting anode/cathode both to low V, then both to mode 0 (read).
        Waits half_flash_length seconds.
    Repeats for total of num_flashes on-off cycles.
    '''
    
    # Retrieving anode and cathode
    [anode, cathode] = LED_array[LED_num]
    
    # Flashing the LED
    for repetition in range(num_flashes):
        # Turning the LED on
        anode.mode = 1
        cathode.mode = 1
        cathode.write(1)
        time.sleep(half_flash_length)
        
        # Turning the LED off
        cathode.write(0)
        cathode.mode = 0
        anode.mode = 0
        time.sleep(half_flash_length)

def LED_PWM(LED_array, LED_num, duty_cycle, duration=0.5):
    '''
    param dict LED_array: key=int corresponding to an LED, value=[anode_pin, cathode_pin]
    param int LED_num: Number corresponding to the LED that should turn on
    param float duty_cycle: Apparent voltage of LED (must be between 0 and 5, inclusive)
    param float duration: Time (in seconds) that the LED should turn on for
    
    Sets anode to mode 1 (write) at low voltage. Sets cathode to mode 3 (PWM) and writes duty_cycle.
    Delays duration seconds.
    Writes 0 to cathode for low voltage. Sets both cathode and anode to mode 0 (read) for default conditions.
    '''
    
    # Retrieving anode and cathode
    [anode, cathode] = LED_array[LED_num]
    
    # Turning the LED on
    anode.mode = 1
    anode.write(0)
    cathode.mode = 3
    cathode.write(duty_cycle)
    time.sleep(duration)
    
    # Turning the LED off
    cathode.write(0)
    cathode.mode = 0
    anode.mode = 0
